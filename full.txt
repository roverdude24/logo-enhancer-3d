<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>LOGO ENHANCER 3000 - 3D Edition</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Lumanosimo&display=swap" rel="stylesheet">
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: Arial, sans-serif;
      background: #121212;
      color: white;
    }
    
    canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
    
    .header {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 100;
      text-align: center;
      pointer-events: none;
      font-family: 'Lumanosimo', cursive;
    }
    
    .header h1 {
      font-size: 32px;
      margin: 0;
      text-shadow: 0 0 10px rgba(0,128,255,0.8);
      letter-spacing: 1px;
    }
    
    .header h2 {
      font-size: 20px;
      margin: 5px 0 0 0;
      opacity: 0.8;
      font-weight: normal;
    }
    
    .upload-container {
      position: fixed;
      left: 20px;
      top: 20px;
      z-index: 100;
    }
    
    button {
      background: rgba(0, 118, 255, 0.8);
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 4px;
      cursor: pointer;
      font-weight: bold;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
      transition: background 0.2s;
    }
    
    button:hover {
      background: rgba(0, 138, 255, 0.9);
    }
    
    input[type="file"] {
      display: none;
    }

    #imageUpload,
    .upload-container input[type="file"] {
      display: none;
    }
    
    .loading-indicator {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 200;
      background: rgba(0,0,0,0.7);
      padding: 20px;
      border-radius: 10px;
      display: none;
    }
    
    .loading-indicator.active {
      display: block;
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>LOGO ENHANCER 3000</h1>
    <h2>Liquid Metal 3D Edition</h2>
  </div>

  <div class="upload-container">
    <input type="file" id="imageUpload" accept=".svg,.png,.jpg,.jpeg">
    <button id="uploadBtn">Upload File</button>
  </div>
  
  <canvas id="glCanvas"></canvas>
  
  <div class="loading-indicator" id="loadingIndicator">
    Processing... Please wait.
  </div>
  
  <script type="module" src="/src/main.js"></script>
</body>
</html>

// src/core/CameraSystem.js
import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

export class CameraSystem {
  constructor(container) {
    this.camera = new THREE.PerspectiveCamera(
      75,
      container.clientWidth / container.clientHeight,
      0.1,
      1000
    );
    
    this.camera.position.set(0, 0, 100);
    
    this.controls = new OrbitControls(this.camera, container);
    this.controls.enableDamping = true;
    this.controls.dampingFactor = 0.05;
    this.controls.rotateSpeed = 0.7;
    
    this.autoRotate = false;
    this.controls.autoRotate = this.autoRotate;
    this.controls.autoRotateSpeed = 1.0;
    
    window.addEventListener('resize', () => {
      this.camera.aspect = container.clientWidth / container.clientHeight;
      this.camera.updateProjectionMatrix();
    });
  }
  
  update() {
    this.controls.update();
  }
  
  lookAt(target) {
    this.camera.lookAt(target);
    this.controls.target.copy(target);
  }
  
  setAutoRotate(value) {
    this.autoRotate = value;
    this.controls.autoRotate = value;
  }
  
  fitToObject(object, offset = 1.5) {
    if (!object) return;
    
    const boundingBox = new THREE.Box3().setFromObject(object);
    const center = new THREE.Vector3();
    boundingBox.getCenter(center);
    
    const size = new THREE.Vector3();
    boundingBox.getSize(size);
    
    const maxDim = Math.max(size.x, size.y, size.z);
    const fov = this.camera.fov * (Math.PI / 180);
    let distance = maxDim / (2 * Math.tan(fov / 2));
    distance *= offset;
    
    this.camera.position.set(center.x, center.y, center.z + distance);
    this.controls.target.copy(center);
    this.camera.lookAt(center);
    this.controls.update();
  }
}

// src/core/EffectManager.js
import * as THREE from 'three';

export class EffectManager {
  constructor() {
    this.params = {
      effectStrength: 0.7,
      distortionAmount: 1.0,
      metalness: 1.0,
      colorShift: 1.0,
      backgroundColor: '#111111',
      showGrid: false, // Changed to false
      wireframe: false,
      autoRotate: false,
      metalPreset: 'silver',
      flowSpeed: 0.5,
      roughness: 0.15,
      dispersionStrength: 1.0,
      dispersionScale: 1.0,
      flowIntensity: 1.0
    };
    
    this.clock = new THREE.Clock();
    this.elapsedTime = 0;
    this.scene = null; // Add scene reference
  }

  setScene(scene) {
    this.scene = scene;
  }
  
  update() {
    this.elapsedTime = this.clock.getElapsedTime();
    return this.elapsedTime;
  }
  
  getParams() {
    return this.params;
  }
  
  setParam(name, value) {
    if (name in this.params) {
      this.params[name] = value;
    }
  }
  
  setMetalPreset(presetName) {
    if (!presetName || !this.scene) return;
    
    this.params.metalPreset = presetName;
    
    // Update all materials
    this.scene.traverse(child => {
      if (child.isMesh && child.material.type === 'ShaderMaterial') {
        const uniforms = child.material.uniforms;
        if (uniforms.u_baseColor && uniforms.u_highlightColor) {
          const preset = METAL_PRESETS[presetName];
          uniforms.u_baseColor.value.copy(preset.baseColor);
          uniforms.u_highlightColor.value.copy(preset.highlightColor);
          uniforms.u_metalness.value = preset.metalness;
          uniforms.u_roughness.value = preset.roughness;
          uniforms.u_flowSpeed.value = preset.flowSpeed;
        }
      }
    });
  }

  updateMaterialUniforms(material) {
    if (!material || !material.uniforms) return;
    
    if (material.uniforms.u_time !== undefined) {
      material.uniforms.u_time.value = this.elapsedTime;
    }
    
    if (material.uniforms.u_effectStrength !== undefined) {
      material.uniforms.u_effectStrength.value = this.params.effectStrength;
    }
    
    if (material.uniforms.u_distortionAmount !== undefined) {
      material.uniforms.u_distortionAmount.value = this.params.distortionAmount;
    }
    
    if (material.uniforms.u_metalness !== undefined) {
      material.uniforms.u_metalness.value = this.params.metalness;
    }
    
    if (material.uniforms.u_colorShift !== undefined) {
      material.uniforms.u_colorShift.value = this.params.colorShift;
    }
    
    if (material.uniforms.u_wireframe !== undefined) {
      material.uniforms.u_wireframe.value = this.params.wireframe;
    }

    if (material.uniforms.u_flowSpeed !== undefined) {
      material.uniforms.u_flowSpeed.value = this.params.flowSpeed;
    }
    if (material.uniforms.u_roughness !== undefined) {
      material.uniforms.u_roughness.value = this.params.roughness;
    }
    if (material.uniforms.u_dispersionStrength !== undefined) {
      material.uniforms.u_dispersionStrength.value = this.params.dispersionStrength;
    }
    if (material.uniforms.u_dispersionScale !== undefined) {
      material.uniforms.u_dispersionScale.value = this.params.dispersionScale;
    }
    if (material.uniforms.u_flowIntensity !== undefined) {
      material.uniforms.u_flowIntensity.value = this.params.flowIntensity;
    }
  }
}

// src/core/SceneManager.js
import * as THREE from 'three';

export class SceneManager {
  constructor() {
    this.scene = new THREE.Scene();
    this.scene.background = new THREE.Color(0x111111);
    
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    this.scene.add(ambientLight);
    
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(0, 10, 10);
    this.scene.add(directionalLight);
    
    const backLight = new THREE.DirectionalLight(0xffffff, 0.3);
    backLight.position.set(0, -5, -10);
    this.scene.add(backLight);
  }
  
  setBackgroundColor(color) {
    this.scene.background = new THREE.Color(color);
  }
  
  addObject(object) {
    this.scene.add(object);
  }
  
  removeObject(object) {
    this.scene.remove(object);
  }
  
  createGridHelper(size = 100, divisions = 20, color1 = 0x444444, color2 = 0x888888) {
    const grid = new THREE.GridHelper(size, divisions, color1, color2);
    grid.material.opacity = 0.2;
    grid.material.transparent = true;
    grid.position.y = -20;
    grid.visible = false; // Set initially invisible
    this.scene.add(grid);
    return grid;
  }
  
  createAxisHelper(size = 20) {
    const axesHelper = new THREE.AxesHelper(size);
    axesHelper.visible = false; // Set initially invisible
    this.scene.add(axesHelper);
    return axesHelper;
  }
}

import { noiseFunction, dispersionUtils } from './shaderUtils.js';

export const dispersionFragmentShader = `
${noiseFunction}
${dispersionUtils}

uniform float u_dispersionStrength;
uniform float u_dispersionScale;
uniform float u_time;
uniform sampler2D u_texture;

varying vec2 vUv;

void main() {
  vec4 texColor = texture2D(u_texture, vUv);
  
  // Calculate dispersion effect
  vec3 dispersed = disperseColor(
    texColor.rgb,
    u_dispersionStrength,
    u_time,
    vUv * u_dispersionScale
  );
  
  gl_FragColor = vec4(dispersed, texColor.a);
}`;


// src/core/SceneManager.js
import * as THREE from 'three';

export class SceneManager {
  constructor() {
    this.scene = new THREE.Scene();
    this.scene.background = new THREE.Color(0x111111);
    
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    this.scene.add(ambientLight);
    
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(0, 10, 10);
    this.scene.add(directionalLight);
    
    const backLight = new THREE.DirectionalLight(0xffffff, 0.3);
    backLight.position.set(0, -5, -10);
    this.scene.add(backLight);
  }
  
  setBackgroundColor(color) {
    this.scene.background = new THREE.Color(color);
  }
  
  addObject(object) {
    this.scene.add(object);
  }
  
  removeObject(object) {
    this.scene.remove(object);
  }
  
  createGridHelper(size = 100, divisions = 20, color1 = 0x444444, color2 = 0x888888) {
    const grid = new THREE.GridHelper(size, divisions, color1, color2);
    grid.material.opacity = 0.2;
    grid.material.transparent = true;
    grid.position.y = -20;
    grid.visible = false; // Set initially invisible
    this.scene.add(grid);
    return grid;
  }
  
  createAxisHelper(size = 20) {
    const axesHelper = new THREE.AxesHelper(size);
    axesHelper.visible = false; // Set initially invisible
    this.scene.add(axesHelper);
    return axesHelper;
  }
}

import { noiseFunction, dispersionUtils } from './shaderUtils.js';

export const dispersionFragmentShader = `
${noiseFunction}
${dispersionUtils}

uniform float u_dispersionStrength;
uniform float u_dispersionScale;
uniform float u_time;
uniform sampler2D u_texture;

varying vec2 vUv;

void main() {
  vec4 texColor = texture2D(u_texture, vUv);
  
  // Calculate dispersion effect
  vec3 dispersed = disperseColor(
    texColor.rgb,
    u_dispersionStrength,
    u_time,
    vUv * u_dispersionScale
  );
  
  gl_FragColor = vec4(dispersed, texColor.a);
}`;

// src/effects/LiquidMetalShader.js
import * as THREE from 'three';
import { noiseFunction, dispersionUtils } from './shaderUtils.js';

// Metal presets
const METAL_PRESETS = {
  gold: {
    baseColor: new THREE.Color(0xffd700),
    highlightColor: new THREE.Color(0xffffcc),
    metalness: 1.2,
    roughness: 0.1,
    flowSpeed: 0.4
  },
  silver: {
    baseColor: new THREE.Color(0xc0c0c0),
    highlightColor: new THREE.Color(0xffffff),
    metalness: 1.0,
    roughness: 0.15,
    flowSpeed: 0.5
  },
  bronze: {
    baseColor: new THREE.Color(0xcd7f32),
    highlightColor: new THREE.Color(0xffdab9),
    metalness: 0.9,
    roughness: 0.25,
    flowSpeed: 0.3
  },
  chrome: {
    baseColor: new THREE.Color(0x8899aa),
    highlightColor: new THREE.Color(0xffffff),
    metalness: 1.5,
    roughness: 0.05,
    flowSpeed: 0.7
  }
};

export const liquidMetalVertexShader = `
varying vec2 vUv;
varying vec3 vNormal;
varying vec3 vViewPosition;

void main() {
  vUv = uv;
  vNormal = normalize(normalMatrix * normal);
  
  vec4 worldPosition = modelMatrix * vec4(position, 1.0);
  vViewPosition = -worldPosition.xyz;
  
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}`;

export const liquidMetalFragmentShader = `
${noiseFunction}
${dispersionUtils}

precision mediump float;
varying vec2 vUv;
varying vec3 vNormal;
varying vec3 vViewPosition;

uniform float u_time;
uniform vec2 u_resolution;
uniform float u_effectStrength;
uniform float u_distortionAmount;
uniform float u_metalness;
uniform float u_colorShift;
uniform sampler2D u_texture;
uniform bool u_hasTexture;
uniform bool u_wireframe;

uniform vec3 u_baseColor;
uniform vec3 u_highlightColor;
uniform float u_roughness;
uniform float u_flowSpeed;

// Simple noise function
float random(vec2 st) {
  return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
}

// Value noise
float noise(vec2 st) {
  vec2 i = floor(st);
  vec2 f = fract(st);
  
  float a = random(i);
  float b = random(i + vec2(1.0, 0.0));
  float c = random(i + vec2(0.0, 1.0));
  float d = random(i + vec2(1.0, 1.0));

  vec2 u = f * f * (3.0 - 2.0 * f);
  return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
}

// Fractional Brownian Motion
float fbm(vec2 st) {
  float value = 0.0;
  float amplitude = 0.5;
  float frequency = 3.0;
  
  for (int i = 0; i < 3; i++) {
    value += amplitude * noise(st * frequency);
    frequency *= 2.0;
    amplitude *= 0.5;
  }
  return value;
}

void main() {
  vec3 normal = normalize(vNormal);
  vec3 viewDir = normalize(vViewPosition);
  
  // Enhanced lighting setup
  vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));
  float diffuse = max(dot(normal, lightDir), 0.0);
  vec3 halfDir = normalize(lightDir + viewDir);
  float specular = pow(max(dot(normal, halfDir), 0.0), 32.0);
  float fresnel = pow(1.0 - abs(dot(normal, viewDir)), 5.0);
  
  // Enhanced flow and dispersion
  float t = u_time * u_flowSpeed;
  vec2 flowUV = vUv + normal.xy * 0.1;
  
  // Create dynamic flow pattern
  float flowPattern = enhancedFBM(vec3(flowUV * 5.0, t));
  vec2 distortedUV = flowUV + vec2(
    enhancedFBM(vec3(flowUV * 3.0 + t, 0.0)),
    enhancedFBM(vec3(flowUV * 3.0, t))
  ) * u_distortionAmount;
  
  // Apply color dispersion with enhanced separation
  vec3 dispersedColor = disperseColor(u_baseColor, u_distortionAmount, t, distortedUV);
  dispersedColor += vec3(0.02, 0.0, -0.02) * u_colorShift * flowPattern;
  
  // Create enhanced metallic effect
  vec3 metallicColor = mix(
    dispersedColor,
    u_highlightColor,
    flowPattern * (1.0 - u_roughness)
  );
  
  // Add dynamic reflections
  metallicColor += specular * u_highlightColor * u_metalness * (1.0 + flowPattern * 0.5);
  metallicColor += fresnel * u_highlightColor * u_metalness;
  
  // Final composition with enhanced lighting
  vec3 finalColor = metallicColor * (0.5 + diffuse * 0.5);
  float alpha = u_hasTexture ? texture2D(u_texture, distortedUV).a : 1.0;
  
  gl_FragColor = vec4(finalColor, alpha);
}`;

export const liquidMetal2DFragmentShader = `
// ...existing uniforms and helper functions...

void main() {
  vec4 texColor = texture2D(u_texture, vUv);
  vec3 normal = normalize(vNormal);
  vec3 viewDir = normalize(vViewPosition);
  
  // Enhanced fresnel effect for 2D
  float fresnel = pow(1.0 - abs(dot(normal, viewDir)), 3.0);
  
  // Apply effect only to non-white areas
  float luminance = (texColor.r + texColor.g + texColor.b) / 3.0;
  float effectMask = 1.0 - smoothstep(0.7, 0.9, luminance);
  
  // Flow effect
  float t = u_time * u_flowSpeed;
  vec2 flowUV = vUv + vec2(
    fbm(vUv * 2.0 + t),
    fbm(vUv * 2.0 - t)
  ) * u_effectStrength * effectMask;
  
  // Sample texture with flow distortion
  vec4 distortedColor = texture2D(u_texture, flowUV);
  
  // Create metallic effect
  vec3 metallicColor = mix(
    u_baseColor,
    u_highlightColor,
    fbm(flowUV * 5.0 + t) * (1.0 - u_roughness)
  );
  
  // Mix based on luminance mask
  vec3 finalColor = mix(
    distortedColor.rgb,
    metallicColor,
    effectMask * u_metalness
  );
  
  // Add highlights and fresnel
  finalColor += fresnel * u_highlightColor * effectMask * u_metalness;
  
  gl_FragColor = vec4(finalColor, texColor.a);
}`;

export function createLiquidMetalMaterial(hasTexture = false, texture = null, preset = 'silver') {
  const metalPreset = METAL_PRESETS[preset] || METAL_PRESETS.silver;
  // Choose shader based on texture presence
  const fragmentShader = hasTexture ? liquidMetal2DFragmentShader : liquidMetalFragmentShader;
  
  const uniforms = {
    u_time: { value: 0 },
    u_resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
    u_effectStrength: { value: 0.7 },
    u_distortionAmount: { value: 1.0 },
    u_metalness: { value: 1.0 },
    u_colorShift: { value: 1.0 },
    u_hasTexture: { value: hasTexture },
    u_wireframe: { value: false },
    u_baseColor: { value: metalPreset.baseColor },
    u_highlightColor: { value: metalPreset.highlightColor },
    u_roughness: { value: metalPreset.roughness },
    u_flowSpeed: { value: metalPreset.flowSpeed }
  };
  
  if (hasTexture && texture) {
    uniforms.u_texture = { value: texture };
  }
  
  return new THREE.ShaderMaterial({
    uniforms: uniforms,
    vertexShader: liquidMetalVertexShader,
    fragmentShader: fragmentShader,
    side: THREE.DoubleSide,
    transparent: true,
    blending: THREE.NormalBlending
  });
}

export const noiseFunction = `
  // Improved 3D noise for better dispersion
  vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
  vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
  vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
  vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

  float improvedNoise(vec3 v) {
    const vec2 C = vec2(1.0/6.0, 1.0/3.0);
    const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);

    vec3 i  = floor(v + dot(v, C.yyy));
    vec3 x0 = v - i + dot(i, C.xxx);
    vec3 g = step(x0.yzx, x0.xyz);
    vec3 l = 1.0 - g;
    vec3 i1 = min(g.xyz, l.zxy);
    vec3 i2 = max(g.xyz, l.zxy);

    vec3 x1 = x0 - i1 + C.xxx;
    vec3 x2 = x0 - i2 + C.yyy;
    vec3 x3 = x0 - D.yyy;

    i = mod289(i);
    vec4 p = permute(permute(permute(
        i.z + vec4(0.0, i1.z, i2.z, 1.0))
        + i.y + vec4(0.0, i1.y, i2.y, 1.0))
        + i.x + vec4(0.0, i1.x, i2.x, 1.0));

    float n_ = 0.142857142857;
    vec3 ns = n_ * D.wyz - D.xzx;

    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);

    vec4 x_ = floor(j * ns.z);
    vec4 y_ = floor(j - 7.0 * x_);

    vec4 x = x_ *ns.x + ns.yyyy;
    vec4 y = y_ *ns.x + ns.yyyy;
    vec4 h = 1.0 - abs(x) - abs(y);

    vec4 b0 = vec4(x.xy, y.xy);
    vec4 b1 = vec4(x.zw, y.zw);

    vec4 s0 = floor(b0)*2.0 + 1.0;
    vec4 s1 = floor(b1)*2.0 + 1.0;
    vec4 sh = -step(h, vec4(0.0));

    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;
    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;

    vec3 p0 = vec3(a0.xy,h.x);
    vec3 p1 = vec3(a0.zw,h.y);
    vec3 p2 = vec3(a1.xy,h.z);
    vec3 p3 = vec3(a1.zw,h.w);

    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
    p0 *= norm.x;
    p1 *= norm.y;
    p2 *= norm.z;
    p3 *= norm.w;

    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
    m = m * m;
    return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
  }

  float enhancedFBM(vec3 x) {
    float v = 0.0;
    float a = 0.5;
    vec3 shift = vec3(100);
    for (int i = 0; i < 4; ++i) {
      v += a * improvedNoise(x);
      x = x * 2.0 + shift;
      a *= 0.5;
    }
    return v;
  }
`;

export const dispersionUtils = `
  vec3 disperseColor(vec3 baseColor, float dispersionAmount, float time, vec2 uv) {
    float r = enhancedFBM(vec3(uv * 1.1, time * 0.5));
    float g = enhancedFBM(vec3(uv * 1.2, time * 0.4));
    float b = enhancedFBM(vec3(uv * 1.3, time * 0.3));
    
    return baseColor + vec3(r, g, b) * dispersionAmount;
  }
`;

import * as THREE from 'three';
import { SVGLoader } from 'three/examples/jsm/loaders/SVGLoader.js';
import { createLiquidMetalMaterial } from '../effects/LiquidMetalShader.js';

export class FileLoader {
  constructor(scene, effectManager) {
    this.scene = scene;
    this.effectManager = effectManager;
    this.svgGroup = new THREE.Group();
    this.scene.add(this.svgGroup);
    this.currentObject = null;
    this.currentType = null;
    this.svgLoader = new SVGLoader();
    this.textureLoader = new THREE.TextureLoader();
  }

  clearCurrentObject() {
    // Only clear SVG group or PNG objects, not the default object
    if (this.currentObject) {
      if (this.currentType === 'svg') {
        while (this.svgGroup.children.length > 0) {
          const child = this.svgGroup.children[0];
          this.svgGroup.remove(child);
          if (child.geometry) child.geometry.dispose();
          if (child.material) child.material.dispose();
        }
      } else if (this.currentType === 'png') {
        this.scene.remove(this.currentObject);
        if (this.currentObject.geometry) this.currentObject.geometry.dispose();
        if (this.currentObject.material) this.currentObject.material.dispose();
      }
      // Don't clear if it's the default object
      if (this.currentObject.userData.type !== 'default') {
        this.currentObject = null;
      }
    }
  }

  async loadFile(file) {
    this.clearCurrentObject();
    const fileName = file.name.toLowerCase();
    
    if (fileName.endsWith('.svg')) {
      return this.loadSVG(file);
    } else if (fileName.match(/\.(png|jpg|jpeg)$/)) {
      return this.loadImage(file);
    } else {
      throw new Error('Unsupported file type');
    }
  }

  async loadSVG(file) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      
      reader.onload = (event) => {
        try {
          const svgData = event.target.result;
          const svgPaths = this.svgLoader.parse(svgData).paths;
          
          if (svgPaths.length === 0) {
            throw new Error('No paths found in SVG');
          }
          
          // Only clear previous SVG objects
          if (this.currentType === 'svg') {
            this.clearCurrentObject();
          }
          
          // Combine all shapes into one geometry
          const shapes = [];
          svgPaths.forEach(path => {
            shapes.push(...path.toShapes(true));
          });
          
          // Create single mesh for all shapes
          const geometry = new THREE.ExtrudeGeometry(shapes, {
            depth: 20,
            bevelEnabled: true,
            bevelThickness: 2,
            bevelSize: 1,
            bevelSegments: 5,
            curveSegments: 64
          });
          
          // Create material with current preset
          const material = createLiquidMetalMaterial(
            false, 
            null, 
            this.effectManager.params.metalPreset || 'silver'
          );
          
          const mesh = new THREE.Mesh(geometry, material);
          this.svgGroup.add(mesh);
          
          // Scale and center
          this.svgGroup.scale.y *= -1;
          
          const bbox = new THREE.Box3().setFromObject(this.svgGroup);
          const size = new THREE.Vector3();
          bbox.getSize(size);
          const center = new THREE.Vector3();
          bbox.getCenter(center);
          
          // Scale to match default object size
          const targetSize = 30; // Same as default torus knot
          const maxDim = Math.max(size.x, size.y, size.z);
          const scale = targetSize / maxDim;
          
          this.svgGroup.scale.multiplyScalar(scale);
          this.svgGroup.position.set(-center.x * scale, -center.y * scale, -center.z * scale);
          
          this.currentObject = this.svgGroup;
          
          // Set type without affecting default object
          if (this.currentObject && !this.currentObject.userData.type) {
            this.currentType = 'svg';
          }
          
          resolve(this.svgGroup);
        } catch (error) {
          reject(error);
        }
      };
      
      reader.onerror = reject;
      reader.readAsText(file);
    });
  }

  async loadImage(file) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      
      reader.onload = (event) => {
        this.textureLoader.load(
          event.target.result,
          (texture) => {
            try {
              const aspectRatio = texture.image.width / texture.image.height;
              const width = 50;
              const height = width / aspectRatio;
              const geometry = new THREE.PlaneGeometry(width, height, 50, 50);
              
              const material = createLiquidMetalMaterial(true, texture, 
                this.effectManager.params.metalPreset || 'silver');
              
              const plane = new THREE.Mesh(geometry, material);
              this.scene.add(plane);
              this.currentObject = plane;
              this.currentType = 'png';
              
              resolve(plane);
            } catch (error) {
              reject(error);
            }
          },
          undefined,
          reject
        );
      };
      
      reader.onerror = reject;
      reader.readAsDataURL(file);
    });
  }

  getCurrentObject() {
    return {
      object: this.currentObject,
      type: this.currentType
    };
  }
}

// Remove standalone functions and export the class
export default FileLoader;

// src/ui/GUIControls.js
import * as dat from 'dat.gui';

export function setupGUI(effectManager, sceneManager, cameraSystem, grid, axesHelper) {
  const params = effectManager.getParams();
  
  const gui = new dat.GUI();
  
  // Fix for control settings visibility
  const metalFolder = gui.addFolder('Metal Settings');
  metalFolder.add(params, 'metalPreset', {
    Silver: 'silver',
    Gold: 'gold',
    Bronze: 'bronze',
    Chrome: 'chrome'
  }).onChange(value => effectManager.setMetalPreset(value));

  metalFolder.add(params, 'metalness', 0, 2).name('Metalness');
  metalFolder.add(params, 'roughness', 0, 1).name('Roughness');
  
  const effectFolder = gui.addFolder('Effect Settings');
  effectFolder.add(params, 'effectStrength', 0, 1).name('Effect Strength');
  effectFolder.add(params, 'distortionAmount', 0, 3).name('Distortion');
  effectFolder.add(params, 'flowSpeed', 0, 2).name('Flow Speed');
  effectFolder.add(params, 'colorShift', 0, 2).name('Color Shift');
  
  // Add dispersion controls
  const dispersionFolder = gui.addFolder('Color Settings');
  dispersionFolder.add(params, 'dispersionStrength', 0, 2).name('Color Separation');
  dispersionFolder.add(params, 'dispersionScale', 0.1, 2).name('Effect Scale');
  
  // Appearance folder
  const appearanceFolder = gui.addFolder('Appearance');
  
  appearanceFolder.addColor(params, 'backgroundColor')
    .name('Background')
    .onChange(value => {
      effectManager.setParam('backgroundColor', value);
      sceneManager.setBackgroundColor(value);
    });
  
  appearanceFolder.add(params, 'showGrid')
    .name('Show Grid')
    .onChange(value => {
      effectManager.setParam('showGrid', value);
      if (grid) grid.visible = value;
    });
  
  appearanceFolder.add({
    toggleAxes: function() {
      axesHelper.visible = !axesHelper.visible;
    }
  }, 'toggleAxes')
    .name('Toggle Axes');
  
  appearanceFolder.open();
  
  // Camera folder
  const cameraFolder = gui.addFolder('Camera');
  
  cameraFolder.add(params, 'autoRotate')
    .name('Auto Rotate')
    .onChange(value => {
      effectManager.setParam('autoRotate', value);
      cameraSystem.setAutoRotate(value);
    });
  
  cameraFolder.add({
    resetCamera: function() {
      // We'll implement this in the main.js
    }
  }, 'resetCamera')
    .name('Reset Camera');
  
  cameraFolder.open();
  
  // Keep folders open by default
  metalFolder.open();
  effectFolder.open();
  dispersionFolder.open();

  // Update GUI visibility based on file type
  gui.updateControlsForFileType = function(fileType) {
    const folders = [metalFolder, effectFolder, dispersionFolder];
    folders.forEach(folder => {
      folder.domElement.style.display = fileType === 'png' ? 'none' : '';
    });
  };

  return gui;
}

// src/utils/defaultObjects.js
import * as THREE from 'three';
import { createLiquidMetalMaterial } from '../effects/LiquidMetalShader.js';

export function createDefaultObject() {
  // Create a default torus knot with liquid metal material
  const geometry = new THREE.TorusKnotGeometry(15, 6, 100, 16, 2, 3);
  const material = createLiquidMetalMaterial(false, null, 'silver');
  
  const torusKnot = new THREE.Mesh(geometry, material);
  torusKnot.userData.type = 'default';
  
  return torusKnot;
}

// src/utils/helpers.js
import * as THREE from 'three';

export function createGrid(scene, size = 100, divisions = 100, color1 = 0x444444, color2 = 0x888888) {
  const grid = new THREE.GridHelper(size, divisions, color1, color2);
  grid.material.opacity = 0.2;
  grid.material.transparent = true;
  grid.position.y = -20; // Position grid below the object
  scene.add(grid);
  return grid;
}

export function createAxisHelper(scene, size = 20) {
  const axesHelper = new THREE.AxesHelper(size);
  scene.add(axesHelper);
  return axesHelper;
}

// src/main.js
import * as THREE from 'three';
import { CameraSystem } from './core/CameraSystem.js';
import { SceneManager } from './core/SceneManager.js';
import { EffectManager } from './core/EffectManager.js';
import { setupGUI } from './ui/GUIControls.js';
import FileLoader from './ui/FileLoader.js';
import { createDefaultObject } from './utils/defaultObjects.js'; // Fixed import

class LogoEnhancer {
  constructor() {
    // DOM elements
    this.canvas = document.getElementById('glCanvas');
    this.fileInput = document.getElementById('imageUpload');
    this.uploadBtn = document.getElementById('uploadBtn');
    
    // Three.js setup
    this.renderer = new THREE.WebGLRenderer({
      canvas: this.canvas,
      antialias: true,
      alpha: true
    });
    this.renderer.setSize(window.innerWidth, window.innerHeight);
    this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    
    // Create scene
    this.sceneManager = new SceneManager();
    
    // Setup camera
    this.cameraSystem = new CameraSystem(this.canvas);
    
    // Setup grid and axes helpers
    this.grid = this.sceneManager.createGridHelper();
    this.axesHelper = this.sceneManager.createAxisHelper();
    
    // Current logo object
    this.currentObject = null;
    
    // Effect manager
    this.effectManager = new EffectManager();
    
    // Set scene reference in EffectManager
    this.effectManager.setScene(this.sceneManager.scene);
    
    // Set up GUI controls
    this.gui = setupGUI(
      this.effectManager,
      this.sceneManager,
      this.cameraSystem,
      this.grid,
      this.axesHelper
    );
    
    // Add resetCamera function to GUI
    const cameraFolder = this.gui.__folders['Camera'];
    const resetCameraController = cameraFolder.__controllers.find(
      controller => controller.property === 'resetCamera'
    );
    
    if (resetCameraController) {
      resetCameraController.object.resetCamera = () => {
        if (this.currentObject) {
          this.cameraSystem.fitToObject(this.currentObject);
        }
      };
    }
    
    // Setup file loader
    this.fileLoader = new FileLoader(this.sceneManager.scene, this.effectManager);
    this.setupFileUpload();
    
    // Create default object
    this.createDefaultObject();
    
    // Handle window resize
    window.addEventListener('resize', () => this.onWindowResize());
    
    // Start animation loop
    this.animate();
  }
  
  setupFileUpload() {
    this.uploadBtn.addEventListener('click', () => this.fileInput.click());
    
    this.fileInput.addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return;
      
      const loadingIndicator = document.getElementById('loadingIndicator');
      if (loadingIndicator) loadingIndicator.classList.add('active');
      
      try {
        const object = await this.fileLoader.loadFile(file);
        this.currentObject = this.fileLoader.getCurrentObject().object;
        this.cameraSystem.fitToObject(object);
        
        if (this.gui && this.gui.updateControlsForFileType) {
          this.gui.updateControlsForFileType(this.fileLoader.currentType);
        }
      } catch (error) {
        console.error('Error loading file:', error);
        alert('Error loading file: ' + error.message);
      } finally {
        if (loadingIndicator) loadingIndicator.classList.remove('active');
        this.fileInput.value = '';
      }
    });
  }
  
  createDefaultObject() {
    this.currentObject = createDefaultObject();
    this.currentObject.userData.type = 'default'; // Mark as default object
    this.currentObject.userData.needsUpdate = true;
    this.currentObject.classList = ['wireframe-toggle'];
    
    this.sceneManager.addObject(this.currentObject);
    this.cameraSystem.fitToObject(this.currentObject);
  }
  
  onWindowResize() {
    this.renderer.setSize(window.innerWidth, window.innerHeight);
    
    this.cameraSystem.camera.aspect = window.innerWidth / window.innerHeight;
    this.cameraSystem.camera.updateProjectionMatrix();
    
    if (this.currentObject) {
      this.currentObject.traverse(child => {
        if (child.isMesh && child.material && child.material.uniforms && 
            child.material.uniforms.u_resolution) {
          child.material.uniforms.u_resolution.value.set(
            window.innerWidth, window.innerHeight);
        }
      });
    }
  }
  
  animate() {
    requestAnimationFrame(() => this.animate());
    
    const time = this.effectManager.update();
    this.cameraSystem.update();
    
    // Update current object
    if (this.currentObject) {
      this.currentObject.traverse(child => {
        if (child.isMesh && child.material && child.material.uniforms) {
          if (child.material.uniforms.u_time) {
            child.material.uniforms.u_time.value = time;
          }
          this.effectManager.updateMaterialUniforms(child.material);
        }
      });
    }
    
    // Also update any objects in the fileLoader if they're different
    if (this.fileLoader && this.fileLoader.getCurrentObject().object && 
        this.fileLoader.getCurrentObject().object !== this.currentObject) {
      const fileObject = this.fileLoader.getCurrentObject().object;
      fileObject.traverse(child => {
        if (child.isMesh && child.material && child.material.uniforms) {
          if (child.material.uniforms.u_time) {
            child.material.uniforms.u_time.value = time;
          }
          this.effectManager.updateMaterialUniforms(child.material);
        }
      });
    }
    
    this.renderer.render(this.sceneManager.scene, this.cameraSystem.camera);
  }
}

document.addEventListener('DOMContentLoaded', () => {
  new LogoEnhancer();
});